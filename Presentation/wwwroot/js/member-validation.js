/**
 * Member Form Validation System
 *
 * - Most of the code has been generated by Gemini AI
 * A comprehensive client-side validation system for member forms that provides:
 * - Real-time validation feedback
 * - Custom validation rules and error messages
 * - Form-level and field-level validation
 * - Password confirmation validation
 * - Visual error indicators
 * - Automatic error message handling
 *
 * Supported Forms:
 * - Add Member Modal Form
 * - Edit Member Modal Form
 *
 * Validation Features:
 * - Required field validation
 * - Minimum length validation
 * - Pattern/regex validation
 * - Custom validator functions
 * - Password matching validation
 * - Live validation on blur
 * - Form submission validation
 */

(function () {
  /**
   * Validation Rules Configuration
   * Defines the validation rules and error messages for each field
   * Each field can have multiple validation rules including custom validators
   */
  const validationRules = {
    FirstName: {
      required: true,
      minLength: 2,
      errorMessages: {
        required: "First name is required",
        minLength: "First name must be at least 2 characters",
      },
    },
    LastName: {
      required: true,
      minLength: 2,
      errorMessages: {
        required: "Last name is required",
        minLength: "Last name must be at least 2 characters",
      },
    },
    Email: {
      required: true,
      pattern: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
      errorMessages: {
        required: "Email is required",
        pattern: "Please enter a valid email address",
      },
    },
    Password: {
      required: true,
      minLength: 6,
      errorMessages: {
        required: "Password is required",
        minLength: "Password must be at least 6 characters",
      },
    },
    ConfirmPassword: {
      required: true,
      validator: function (value, form) {
        // Find and compare with password field
        const passwordField = form.querySelector('[name="Password"]');
        if (!passwordField) return true;
        return value === passwordField.value;
      },
      errorMessages: {
        required: "Please confirm your password",
        validator: "Passwords do not match",
      },
    },
    Phone: {
      pattern: /^(\+\d{1,3}[- ]?)?\d{10,}$/,
      errorMessages: {
        pattern: "Please enter a valid phone number",
      },
    },
  };

  /**
   * Field Validation
   * Validates a single form field against its defined rules
   * Handles error message display and visual feedback
   *
   * @param {HTMLElement} field - The form field to validate
   * @param {HTMLFormElement} form - The parent form
   * @returns {boolean} - Whether the field is valid
   */
  function validateField(field, form) {
    const fieldName = field.getAttribute("name") || field.id;
    const rules = validationRules[fieldName];

    if (!rules) return true; // Skip validation if no rules defined

    // Get and normalize field value
    let value = field.value;
    if (typeof value === "string") {
      value = value.trim();
    }

    /**
     * Error Element Management
     * Finds or creates the error message element using multiple strategies:
     * 1. Look for .text-danger in parent
     * 2. Look for data-valmsg-for attribute
     * 3. Look for asp-validation-for attribute
     * 4. Create new error element if none found
     */
    let errorElement =
      field.parentElement.querySelector(".text-danger") ||
      field.parentElement.querySelector(
        "[data-valmsg-for='" +
          fieldName +
          "'], [asp-validation-for='" +
          fieldName +
          "']"
      );

    // Extended error element search
    if (!errorElement) {
      errorElement = form.querySelector(
        "[data-valmsg-for='" +
          fieldName +
          "'], [asp-validation-for='" +
          fieldName +
          "']"
      );

      // Create new error element if none found
      if (!errorElement) {
        errorElement = document.createElement("span");
        errorElement.className = "text-danger";

        if (field.parentElement) {
          field.parentElement.appendChild(errorElement);
        } else {
          field.insertAdjacentElement("afterend", errorElement);
        }
      }
    }

    // Required field validation
    if (rules.required && (!value || value.length === 0)) {
      field.classList.add("invalid");
      field.style.borderColor = "red";
      errorElement.textContent = rules.errorMessages.required;
      return false;
    }

    // Minimum length validation
    if (rules.minLength && value.length < rules.minLength) {
      field.classList.add("invalid");
      field.style.borderColor = "red";
      errorElement.textContent = rules.errorMessages.minLength;
      return false;
    }

    // Pattern/regex validation
    if (rules.pattern && value && !rules.pattern.test(value)) {
      field.classList.add("invalid");
      field.style.borderColor = "red";
      errorElement.textContent = rules.errorMessages.pattern;
      return false;
    }

    // Custom validator function
    if (rules.validator && !rules.validator(value, form)) {
      field.classList.add("invalid");
      field.style.borderColor = "red";
      errorElement.textContent = rules.errorMessages.validator;
      return false;
    }

    // Clear validation state for valid field
    field.classList.remove("invalid");
    field.style.borderColor = "";
    errorElement.textContent = "";
    return true;
  }

  /**
   * Form Validation
   * Validates an entire form and manages error display
   * Excludes certain fields (e.g., IsActive checkbox) from validation
   *
   * @param {HTMLFormElement} form - The form to validate
   * @returns {boolean} - Whether the form is valid
   */
  function validateForm(form) {
    let isValid = true;
    const formFields = form.querySelectorAll(
      "input:not([type=hidden]), select, textarea"
    );

    // Remove any existing error summary
    const existingErrorMessage = form.querySelector(".form-error-message");
    if (existingErrorMessage) {
      existingErrorMessage.remove();
    }

    // Validate all applicable form fields
    formFields.forEach((field) => {
      // Skip validation for specific fields
      if (field.type === "checkbox" && field.name === "IsActive") return;

      const fieldValid = validateField(field, form);
      isValid = isValid && fieldValid;

      // Update field group styling
      const fieldGroup = field.closest(".field-group");
      if (fieldGroup) {
        if (!fieldValid) {
          fieldGroup.classList.add("has-error");
        } else {
          fieldGroup.classList.remove("has-error");
        }
      }
    });

    // Display form-level error message if invalid
    if (!isValid) {
      const errorMessage = document.createElement("div");
      errorMessage.className = "alert alert-danger form-error-message";
      errorMessage.innerHTML =
        "<span>Please fix the form errors before submitting.</span>";
      form.prepend(errorMessage);

      // Scroll to form top for visibility
      form.scrollIntoView({ behavior: "smooth", block: "start" });

      // Auto-remove error message after 5 seconds
      setTimeout(() => {
        errorMessage.remove();
      }, 5000);
    }

    return isValid;
  }

  /**
   * Form Setup
   * Configures validation handlers for a specific form
   *
   * @param {string} formSelector - CSS selector for the form
   * @param {string} formName - Name of the form for logging
   * @returns {HTMLFormElement|null} - The configured form or null if not found
   */
  function setupForm(formSelector, formName) {
    const form = document.querySelector(formSelector);
    if (!form) return null;

    console.log(`${formName} form found, setting up validation`);

    // Form submission validation
    form.addEventListener("submit", function (e) {
      if (!validateForm(this)) {
        e.preventDefault();
        e.stopPropagation(); // Prevent modal from closing
        console.log(`${formName} form validation failed`);
      } else {
        console.log(`${formName} form is valid, submitting...`);
      }
    });

    // Set up field-level validation
    form
      .querySelectorAll("input:not([type=hidden]), select, textarea")
      .forEach((field) => {
        // Validate when field loses focus
        field.addEventListener("blur", function () {
          validateField(this, form);
        });

        // Clear validation state on input
        field.addEventListener("input", function () {
          this.style.borderColor = "";
          this.classList.remove("invalid");

          // Clear field group error state
          const fieldGroup = this.closest(".field-group");
          if (fieldGroup) {
            fieldGroup.classList.remove("has-error");
          }

          // Clear error message
          const errorElement = this.parentElement.querySelector(".text-danger");
          if (errorElement) {
            errorElement.textContent = "";
          }
        });
      });

    return form;
  }

  /**
   * Initialization
   * Sets up validation for all member forms
   */
  function init() {
    // Initialize both member forms
    setupForm("#addMemberModal form", "Add Member");
    setupForm("#editMemberModal form", "Edit Member");
  }

  // Initialize on page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }

  // Re-initialize when modals are opened
  document.addEventListener("click", function (e) {
    if (
      e.target &&
      (e.target.getAttribute("data-target") === "#addMemberModal" ||
        e.target.getAttribute("data-target") === "#editMemberModal")
    ) {
      // Wait for modal to open
      setTimeout(init, 100);
    }
  });
})();
